### [从零开始] 使用react(umi)技术栈构建一个后台项目

> 使用react也有两周时间了，是时候来记录一下自己学习和使用react做后台项目的一些小事了。

​	首先列一下近期的学习内容：

* `react`编程方式

  * `jsx`
  * 组件化
  * 组件通信
  * 事件分发和响应
  * 使用`ref`来调用子组件方法
  * 生命周期

  在`react`项目中大量使用了`纯函数`、`解构`、`闭包`等基础的`JavaScript`相关概念，因此在学习使用`react`的过程中推荐也花点时间去学学这些基础，基础扎实点，可能会让你提供对用户更好的`api`，写出来的东西也更容易维护。

* `redux`

  `redux`是一个框架无关的状态管理库，也可以看作是一种编程思想，用于将`视图`、`数据`和`事件`分离，让我们能写出更清晰的业务结构。

  * `react-redux`

    个人觉得，核心就是`分离`两个字。学习过程中可以问自己几个问题

    * 数据中心为什么只有一个？

      一个应用就只应该存在一个数据中心，便于我们追查数据流向。模块内容应该使用命名空间的方式加以区分。

    * `reducer`、`action`和`effect`的区别？他们各自做了什么？分别在什么场景下使用他们？(`effect`实际上是处理了异步，需要另行引入异步处理逻辑`redux-thunk`或者`redux-saga`)

      `reducer`响应一次`dispatch`事件，返回新的`state`，并且`state`本身会决定自己需要更新的内容(不是全量覆盖，而是替换修改部分)，新的`state`触发新的`视图`渲染。`action`为我们定义一类事件，被`dispatch`分发到`redux`处理中心，被`reducer`等响应。`effect`处理那些会带来副作用(`side effect`)的事件。

    * `connect`做了什么？带来什么好处？

      将`视图`和`模型数据`连接起来，给组件注入`状态`和`事件`，当然这里注入的`状态`和`数据`是由`redux`管理的。

* `dva`

  这个库的优点就是自己集成了`redux-sage`和`react-router`，然后给你提供了一个较好的`api`调用。核心就是在`model`内定义如下内容：

  * `namespace` 命名空间，调用事件的时候需要指定在哪个命名空间内产生作用
  * `state` 一个特定空间下的数据模型
  * `action` 事件类型，和`redux`概念中的没什么两样
  * `dispatch` 分发事件到`model`内，由``reducer`或者`effect`响应
  * `reducer` 同`redux.reducer`
  * `effect` 同`redux-saga.effect`
  * `subscription`订阅那些全局变化，并作出响应

  其他的那些使用方法和我们做`状态管理`或者`路由管理`的时候差不多

* `react-router`

  这个库暂时没了解多少，待深入

* `umi`

  终于到`umi`了。在我的使用中，我感觉到它做了这些事

  * 配置化

    由约定的配置方式代替编码，这个确实省了挺多时间。比如`路由`就可以被配置，在`layouts`中配置好页面布局后，组件可以用引入`children`的方式代替编码路由，路由来源于`pages`页面配置的文件。所以这里需要记住一些特定的路径。还有就是`model`都是约定了作用，model用的就是dva，配置和使用起来差不多

  * mock

    mock可以很方便，其实也是和上面讲的配置化相关的，默认了`mock`下哪些路径是用来定义`mock`数据。这在开发接口的时候用的挺多，很方便。

  * 构建

    构建的时候，`dev`环境自动切入`mock`，另外有些以前在`webpack`中配置的内容都放置到`.umirc`中做，省了挺多事。`.env`中配置`umi dev`时需要的变量。

  * 整合

    `umi`是一个比较完整的企业级项目脚手架，相当于整合了`react`、`redux`、`redux-saga`、`react-router`、`dva`等内容，并且在很多地方采用了默认的规范。

  了解完它的内容，最好还是深入研究一下，并问一下自己，是否可以也写一个这样的整合脚手架，哪怕小一点但是功能齐全？

* `antd`

  `ui`组件库，按官方来说，他们还融入了自己的设计哲学...这个就比较悬了，见仁见智吧，第一步是用起来。

#### 工程熟悉

我所接手的项目，是由别人已经建好了的工程，架子已经有了，但是功能不多，就一个功能。目前一段时间都在这个项目中增加内容。因此总结一下常用的内容：

```javascript
// 工程结构及功能介绍
// - assets 静态资源
// - config 是umi配置的文件，需要扩展功能时使用
// - mock 写接口的mock数据
// - public 用意不明确，猜测应该是和index页面相关
// - src/layouts 布局页面，内含index为主入口，其余布局由自己定义
// - src/models 定义dva的model，数据、事件等内容都在这，业务核心
// - src/pages 定义路由页面，支持嵌套文件，嵌套文件会生成嵌套路由
// - .env 配置dev环境的变量，比如联调的时候需要指定一个DEV_HOST
// - .umirc 配置umi相关的，比如打包怎么打、引入哪些插件、代理服务等等
```

因此这么一整理，就不用畏惧了(很多人对学习新的框架存在畏惧感，其实在沉下心来认识它之后，会发现也不过如此)

#### 业务抽象

后台项目经常会遇到很多表单和表格的数据结构，本次由于业务内容较清晰，抽象起来很容易

* 功能：报表数据查询、筛选、导出
  * 不同处
    * 每个报表需要的查询条件不一样
    * 列表数据不一样
    * 表单条目不一样
    * 接口地址不一样
    * 路由不一样
  * 共同处
    * 表单区域
    * 功能区域
    * 列表区域
    * 表单样式统一
    * 筛选功能一致性
    * 导出功能一致性

因此，只需要把共性抽出来形成公共组件，特性做成配置，一个功能就可以快速开发完成了。

具体思路：

1. 配置`api`接口，多个

   * `api`功能确定

2. 配置表单条目和各自的校验规则，每个报表不一样

   * 表单公共区域布局

   * 开发表单子项各自的组件
   * 开发工厂函数，根据传入条目数组来生成表单
   * 工厂函数提供对外调用接口

3. 配置路由

   由于`umi`路由根据配置约定(应该也可以写到代码里，待深入研究)，因此针对不同报表需要写不同的页面

4. 构建基础组件

   * 头部表单由表单工厂函数生成
   * 查询接口
   * 筛选接口
   * 底部表格独立构建一个
   * 整合逻辑流程，对外需要表单、路由、查询接口等信息，产出一个列表

##### 编码实现

代码不具有通用性，也就不贴上来了


